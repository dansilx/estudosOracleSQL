=================================================================================================================================================

AULA 05 

=================================================================================================================================================

ORACLE DATABASE -> DATAFILE -> TABLESPACE

-- criando tablespace

CREATE TABLESPACE curso 
	DATAFILE 	
	'C:\oraclexe\app\oracle\oradata\XE\curso.dbf' -- indicação do caminho onde o tablespace será criado
		size 100m autoextend on next 50m maxsize 500m
	online
	permanente
	extend management local autollocate
	segment space management auto;

-- criando user

CREATE USER aluno -- criação do usuário
	IDENTIFIED BY aluno -- senha 
	DEFAULT TABLESPACE curso -- direcionamento do tablespace
	TEMPORARY TABLESPACE TEMP; -- 
 
-- permissão para aluno

GRANT CREATE SESSION, CONNECT, RESOURCE TO aluno; -- permissões de conexões

ALTER USER ALUNO QUOTA UNLIMITED ON curso; -- alter para não ter limite no tablespace curso

-- deletar user
DROP USER aluno;

-- deletar tablespace 
DROP TABLESPACE curso
	INCLUDING CONTENTS AND DATAFILES 
		CASCADE CONTRAINTS;	

=================================================================================================================================================

AULA 11 - CARACTERISTICAS DE BANCO DE DADOS RELACIONAL

=================================================================================================================================================


Características do DB Relacional 

- É a arquitetura na qual os dados são armazenados em tabelas que se relacionam entre si.

	* Permite controle de redundância de dados;
	* Garantia de integridade dos dados;
	* Garantia de privacidade;
	* Otimização de espaço de Armazenamento;
	* Controle automático de relacionamento entre tabelas de dados;
	* Performance de acesso a informação;
	* Cada tabela (relação) tem seu nome diferente das demais na mesma base de dados;
	* Cada coluna tem seu nome diferente das demais na mesma tabela;
	* Colunas contém os atributos (todos do mesmo domínio);
	* Linhas contém informações de um registro (uma tupla) da tabela;
	* Cada célula pode conter no máximo um item de dado;
	* Ordem das linhas é irrelevante;
	* Ordem das colunas é irrelevante;
	* Nunca temos duas linhas iguais;
	* Chave primária;


=================================================================================================================================================

AULA 16 - ACID E CRUD

=================================================================================================================================================


ACID: (Propriedades das transações)
	
	* Atomicidade: uma transação é uma unidade atômica de processamento; ou ela é executada na sua totalidade, ou então nada é executado.
	* Consistência: a execução de uma transação deve manter a consistência de um banco de dados.
	* Isolamento: uma transação não deve tornar visível para outras transações as modificações feitas em um banco de dados até que ela seja encerrada com sucesso.
	* Durabilidade: uma vez executada com sucesso, as alterações feitas por uma transação deve, persistir, mesmo se houver subsequentes no sistema.


CRUD 
	* CREATE (CRIAR);
	* READ (SELECT);
	* UPDATE (ATUALIZAR);
	* DELETE (APAGAR);

=================================================================================================================================================

AULA 17 - CONSTRAINTS

=================================================================================================================================================

São utilizadas para especificar regras de armazenamento de dados nas tabelas e garantir integridade.

	* NOT NULL: Garante que uma coluna não recebera valor NULL;
	* UNIQUE: Garante que os valores em uma coluna sejam diferentes.
	* PRIMARY KEY: Chave única, linha exclusiva 
	* FOREIGN KEY: Referencia o valor de um campo em determinada linha a outra tabela 
	* DEFAULT: Define um valor padrão para uma coluna quando nenhum valor é especificado 
	* INDEX: Usado para criar e recuperar dados do banco de dados, melhor performance


=================================================================================================================================================

AULA 18 - OPERADORES DE COMPARAÇÃO 

=================================================================================================================================================

*** Permissões para select

GRANT SELECT ON HR.COUNTRIES TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.DEPARTMENTS TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.EMPLOYEES TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.JOB_HISTORY TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.JOBS TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.LOCATIONS TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.REGIONS TO ALUNO WITH GRANT OPTION;

-- EXEMPLO OPERADOR IGUAL =
SELECT * FROM HR.EMPLOYEES A
WHERE A.JOB_ID = 'IT_PROG';

-- EXEMPLO OPERADOR IGUAL =
SELECT * FROM HR.EMPLOYEES A
WHERE A.SALARY = '9000';

-- EXEMPLO OPERADOR MAIOR >
SELECT * FROM HR.EMPLOYEES A
WHERE A.HIRE_DATE > '03/02/2006'
ORDER BY A.HIRE_DATE ASC;

-- EXEMPLO OPERADOR MAIOR >

SELECT * FROM HR.EMPLOYEES A 
WHERE A.SALARY > '9000'
ORDE BY A.SALARY ASC;

-- EXEMPLO OPERADOR MENOR < 

SELECT * FROM HR.EMPLOYEES A
WHERE A.HIRE_DATE < '03/02/2006'
ORDER BY A.HIRE_DATE ASC;


-- EXEMPLO OPERADOR MAIOR IGUAL >=



=================================================================================================================================================

AULA 19 - OPERADORES MATEMÁTICOS 

=================================================================================================================================================

	+ ADIÇÃO
	- SUBTRAÇÃO
	* MULTIPLICAÇÃO
	/ DIVISÃO
	% MÓDULO -> RETORNA O RESTO INTEIRO DE UMA DIVISÃO

=================================================================================================================================================

AULA 20 - OPERADORES LÓGICOS/FILTROS

=================================================================================================================================================

WHERE - usada para extrair somente os registros/linhas que estiverem dentro das especificações da condição 
AND - TRUE se as duas expressões booleanas forem TRUE
BETWEEN - TRUE se o operando estiver dentro de um intervalo 
IN - TRUE se o operando for igual a um de uma lista de expressões 
LIKE - TRUE se o operando corresponder a um padrão
NOT - inverte o valor de qualquer outro operador booleano
OR - TRUE se qualquer expressão booleana for TRUE 
IS NULL - TRUE se o o valor for NULO
IS NOT NULL - TRUE se o valor não for NULO
HAVING - A cláusula HAVING foi adicionada ao SQL porque a palavra-chave WHERE não pôde ser usada com funções agregadas


CREATE TABLE senso 
(
ano INT NOT NULL,
cod_uf CHAR(2) NOT NULL,
estado VARCHAR(50) NOT NULL,
cod_mun CHAR(7) NOT NULL,
nome_mun varchar(50) NOT NULL,
regiao VARCHAR(150) NOT NULL,
pib DECIMAL(12,3) NOT NULL,
populacao INTEGER NOT NULL
);

=================================================================================================================================================

AULA 22 - STATMENT LANGUAGE

=================================================================================================================================================

DML - Data Manipulation Language
	SELECT - retornar dados do banco de dados
	INSERT - inserir dados em uma tabela
	UPDATE - atualiza dados existentes em uma tabela
	DELETE - exclui registros de uma tabela
DDL - Data Definition Language
	CREATE - para criar objetos no BD, o próprio BD, tabelas, indexes, procedures, views, functions, triggers
	ALTER - altera a estrutura do BD, o próprio BD, tabelas, indexes
	DROP - apaga objeto do BD, próprio BD, tabelas, indexes, procedures, views, triggers, e functions
	TRUNCATE - remove todos os registros de uma tabela, incluindo todos os espaços alocados para registros 
DCL - Data Control Language
	GRANT - atribui privilégios de acesso do usuário a objetos do BD
	REVOKE - remove privilégios de acesso do usuário a objetos do BD obtidos através do comando GRANT
TCL - Transaction Control Language                
	START TRANSACTION - 
	COMMIT - salvar o trabahlo feito
	SAVEPOINT - identificar um ponto em uma transação para que mais tarde possa efetua um ROLLBACK
	ROLLBACK - restaura BD ao original desde último COMMIT

=================================================================================================================================================

AULA 24 - DDL

=================================================================================================================================================

CREATE TABLE 
CREATE SEQUENCE 
CREATE INDEX

ALTER TABLE FUNCIONARIO ADD GENERO CHAR(1); -- adicionar campo

ALTER TABLE FUNCIONARIO RENAME COLUMN GENERO TO SEXO; --renomear coluna

ALTER TABLE FUNCIONARIO MODIFY SEXO VARCHAR2(1); --modificar tipo da coluna 

ALTER TABLE FUNCIONARIO RENAME TO PESSOA; -- renomear a tabela

ALTER TABLE PESSOA RENAME TO FUNCIONARIO; 

ALTER TABLE SENSO ADD ID INT; 

ALTER TABLE SENSO DROP COLUMN ID; --remover a coluna

ALTER TABLE FUNCIONARIO MODIFY ENDERECO VARCHAR2(30);

CREATE DATABASE TESTE; -- criar um banco de dados

DROP DATABASE TESTE; -- remover um banco de dados

DROP TABLE SALARIO;

CREATE VIEW V_FUNCIONARIO
 AS SELECT * FROM FUNCIONARIOS;

CREATE OR REPLACE VIEW V_FUNCIONARIO
AS SELECT ID, NOME FROM FUNCIONARIOS;

DROP  VIEW V_FUNCIONARIO;

CREATE OR REPLACE PROCEDURE PROC_QUADRADO (V_MUM1 NUMBER)
IS 
V_MUM2 NUMBER
BEGIN 
	V_MUM2 := V_MUM1 * V_MUM1;
	DBMS_OUTPUT.PUT_LINE('Retorno: ' || v_mum2);
END;

--CALL PROCEDURE 

BEGIN 
	POC_QUADRADO(V_MUM1 => 2)
END;

OU

SET SERVEROUTPUT ON;
EXECUTE PROC_QUADRADO(7);

DROP PROCEDURE PROC_QUADRADO;

CREATE GLOBAL TEMPORARY TABLE TMP_FUNCIONARIOS -- uma tabela tempoária só armazena os dados no tempo de uma próxima transação
(
	ID INT,
	NOME VARCHAR2(50),
	SALARIO DECIMAL(10, 2),
	SETOR VARCHAR2(30)
);

=================================================================================================================================================

AULA 26 - DCL GRANT

=================================================================================================================================================


GRANT UPDATE ON ALUNO.FUNCIONARIOS TO ALUNO;

GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW TO ALUNO WITH ADMIN OPTION;

GRANT SELECT, UPDATE ON ALUNO.SENSO TO ALUNO;

GRANT INSERT, DELETE ON ALUNO.SENSO TO ALUNO;

GRANT CREATE PROCEDURE, CREATE VIEW TO ALUNO;

SELECT 'GRANT ALL ON ' || object_name || ' TO ALUNO;' AS RETONO
	FROM USER_OBJECTS;


=================================================================================================================================================

AULA 26 - DCL REVOKE

=================================================================================================================================================

REVOKE CREATE VIEW, CREATE PROCEDURE, CREATE SESSION, CREATE TABLE FROM ALUNO;

REVOKE RESOURCE FROM ALUNO;

REVOKE UPDATE ON HELP FROM ALUNO;

=================================================================================================================================================

AULA 28 - TCL

=================================================================================================================================================


CREATE TABLE CADASTRO 
(
	NOME VARCHAR2(50) NOT NULL,
	NRO_DCTOVARCHAR2(20) NOT NULL
);

INSERT INTO CADASTRO VALUES ('Andre', '1234567');
INSERT INTO CADASTRO VALUES ('Joao', '9876541');
INSERT INTO CADASTRO VALUES ('Bruno', '1111111111');

ROLBACK;

COMMIT;

INSERT INTO CADASTRO VALUES ('Andre', '1234567');
SAVEPOINT P1;
INSERT INTO CADASTRO VALUES ('Joao', '9876541');
SAVEPOINT P2;
INSERT INTO CADASTRO VALUES ('Bruno', '1111111111');
SAVEPOINT P3;

ROLLBACK TO SAVEPOINT P2;

COMMIT;

=================================================================================================================================================

AULA 29 - OPERADOR UNION / UNION ALL

=================================================================================================================================================

Operador UNION é usado para combinar o conjunto de resultados de duas ou mais instruções SELECT 
É necessário que cada select dentro do union possua o mesmo número de colunas e do mesmo tipo
As colunas também devem ser tipos de dados semelhantes 
As colunas em cada instrução select deve estar na mesma ordem 
O operador UNION seleciona apenas valores distintos por padrão (realiza um DISTINCT)
Para permitir valores duplicados é necessário o UNION ALL



=================================================================================================================================================

AULA 30 - JOINS

=================================================================================================================================================


Esta clausula é suada para combinar as linhas de duas ou mais tabelas baseado no relacionamento entre elas.

Aqui estão os diferentes tipos de JOINS em SQL:

  * INNER JOIN: Retorna os registros que têm valores correspondentes em ambas as tabelas
  * LEFT JOIN: Retorna todos os registros da tabela à esquerda e os registros correspondentes da tabela da direita  
  * RIGHT JOIN: Retorna todos os registros da tabela à diretia e os registros correspondentes da tabela da esquerda  
  * FULL OUTER JOIN: retorna todos os registros quando houver uma correspondência na tabela à esquerda ou à direita

*************************************************************************************************************************************************  
*** Consulta para verificar todas as tabelas				***  Consulta para verificar tipos 	  			      ***
***									***								      ***
*** SELECT OWNER, TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH	***  SELECT OWNER, TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH    ***
*** FROM all_tab_columns						***  FROM all_tab_columns					      ***
***									***  WHERE DATA_TYPE = 'VARCHAR'				      ***
***									***								      ***
*************************************************************************************************************************************************


=================================================================================================================================================

AULA 31 - SUBQUERYS

=================================================================================================================================================

É uma instrução SELECT que está condicionada dentro de outra instrução SQL.

Existem, no entanto, 4 maneiras de introduzirmos uma subconsulta em uma instrução do tipo SELECT:
	
	* Através do WHERE como sendo uma condição de pesquisa
	* Em uma cláusula HAVING como condição de pesquisa
	* na cláusula FROM como uma especificação de tabela
	* na cláusula SELECT como uma especificação de coluna   


=================================================================================================================================================

*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*  FUNÇÕES PADRÕES  */*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*

=================================================================================================================================================

AULA 33 e 34 - FUNÇÕES DE AGREGAÇÃO

=================================================================================================================================================

Executam um cálculo em um conjunto de valores e retornam um único valor.
Com exceção de COUNT, as funções de agregação ignorma valores nulos.
A funções de agregação normalmente são usadas com a cláusula GROUP BY da instrução SELECT
As funções de agregação podem ser usadas como expressões apenas nos seguintes casos:
  * A lista de seleção de uma instrução select (uma subconsutla ou uma consulta externa)
  * Uma cláusula HAVING.


AVG - Retorna a média dos valores em um grupo. Valores nulos são ignorados
MIN - Retorna o valor mínimo da expressão. Pode ser seguido pela cláusula OVER
MAX - Retorna o valor máximo na expressão
SUM - Retorna a soma de todos os valores ou somente os valores DISTINCT na expressão. 
      SUM pode ser usado exclusivamente com colunas numéricas. Valores nulos são ignorados 
COUNT - Retorna o número de itens de um grupo
STDDEV - Retorna o desvio padrão estatístico de todos os valores da expressão especificada 
VARIANCE - Determina a variância de N,ignorando valores nulos  

-- consulta que traz o estado, 
-- sua média populacional agrupado por estado, 
-- população mínima, população máxima, 
-- soma da população agrupado por estado 
-- e a quantidade de cidades tendo em vista a contagem de linhas agrupado por estado e ano 
-- (ano nesse caso auxilia a ter uma exatidão pois se não separasse por ano traria o registro de todos anos)  

SELECT 
	a.estado,
       	AVG(a.populacao) as media_pop,
	MIN(a.populacao) as minimo_pop,
	MAX(a.populacao) as maximo_pop,
	SUM(a.populacao) as total_pop,
	COUNT(*) as qtd_cidades
FROM senso a 
WHERE a.ano = '2014'
GROUP BY a.estado
ORDER BY 2 DESC;

-- consulta mais aprimorada em relação a outra que só demonstrava números
-- nela é possível verificar o nome do estado e do município com a população máxima

SELECT a.estado, a.nome_mun, a.populacao
FROM
	(SELECT b.estado, MAX(b.populacao) as populacao from senso b
	 WHERE b.ano = '2014'
	 GROUP BY b.estado
	) b
JOIN senso a
ON a.estado = b.estado
AND a.populacao = b.populacao
WHERE a.ano = '2014'
ORDER BY a.populacao DESC; 


-- COMPARANDO CRESCIMENTO pop DA CIDADES ref anos  2010 a 2014
-- select cod_uf,cod_mun,cod_uf+cod_mun as concatenado from cidades
-- usando exemplo
SELECT a.nome_mun,
       a.populacao as senso_2010,
	   b.populacao as senso_2014,
       (100/a.populacao)*(b.populacao)-100 as percentual
from senso a 
inner join senso b 
on a.cod_mun=b.cod_mun
where a.ano='2010' 
and b.ano='2014';

-- VAR_POP Retorna a variância estatística de todos os valores da expressão especificada
SELECT VAR_POP(POPULACAO) FROM senso
where ano='2014';

-- VAR_SAMP Retorna a variância estatística para o preenchimento 
-- de todos os valores da expressão especificada.
SELECT VAR_SAMP(POPULACAO) FROM senso;


=================================================================================================================================================

AULA 39 - FUNÇÕES MATEMÁTICAS

=================================================================================================================================================

	* ABS - Uma função matemática que retorna o valor absoluto (positivo) da expressão numérica especificada
	* DBMS_RANDOM - Retorna um valor float pseudoaleatório de 0 a 1, exclusivo
	* ROUND - Retorna um valor numérico, arredondado, para o comprimento ou precisão especificados
	* TRUNC - Trunca as casas decimais de uma expressão
	* SQRT - Retorna a raiz quadrada de uma expressão
	* SIGN - Retorno -1 para negativo, 0 neutro, 1 para positivo com o valor da expressão
	* POWER - Eleva à potência de N o valor. Pode ser nagativo
	* MOD - Retorna o valor MOD, a sobra de uma expressão dividida
	* EXP - Devolve o valor 'e' elevado a N

=================================================================================================================================================

AULA 40 - FUNÇÕES DE CRIPTOGRAFIA

=================================================================================================================================================

	* RAWTOHEX - Converte os caracteres para hexadecimal
	* DBMS_OBFUSCATION_TOOLKIT - Esse pacote disponibiliza o método MD5 e outros 
	* UTL_RAW - Nesse ponto há manipulação dos dados, tendo como foco principal: a conversão dos tipos
	

SET SERVEROUTPUT ON


DECLARE
     v_str VARCHAR2(100);
     v_frase VARCHAR2(100);
    BEGIN
     -- atribuindo valor
     v_frase:='Utilidades Oracle';
      --generate encoded value
      --1 PARAM BUF VALOR
      --2 PARAM ENCODE_CHARSET SAO TIPO WE8ISO8859P1 - AL32UTF8
      --3 PARAM ENCODING - BASE64
      v_str := utl_encode.text_encode(v_frase,'WE8ISO8859P1', UTL_ENCODE.BASE64);
      --imprimi valor
      dbms_output.put_line(v_str);
      
      --take the encoded value and decode it
      v_str := utl_encode.text_decode(v_str,'WE8ISO8859P1', UTL_ENCODE.BASE64);
      --imprimi valor
     dbms_output.put_line(v_str);
     
   END;


=================================================================================================================================================

AULA 41 - FUNÇÕES DE LIMITE

=================================================================================================================================================

	* ROWNUM - A cláusula SELECT ... LIMIT é útil em grandes tabelas com milhares de registros 
	


=================================================================================================================================================

AULA 42 - FUNÇÕES DE CONVERSÃO

=================================================================================================================================================

	* CAST - Converte expressão de um tipo de dados em outro
	* TO_CHAR(data) - Converte data em string
	* TO_DATE(string) - Converte string em data 
	* NVL() - Trata valor nulo 


=================================================================================================================================================

AULA 43 - FUNÇÕES DE DATAS

=================================================================================================================================================	


	* SYSDATE - Retorna a data e hora atual do servidor 
	* ADD_MONTHS - Adiciona N meses de calendário à data. O número N tem que ser inteiro e pode ser negativo
	* MONTHS_BETWEEN - Determina o número de meses entre data1 e data2. O resultado pode ser positivo ou negativo.
	* LAST_DAY - Devolve o último dia do mês de data1 
	* NEXT_DAY - Devolve a data do próximo dia da semana especificado por C e A seguido da data1

Utilização de operadores aritméticos

	* DATE + NUMBER - Adiciona um número de dias à data, retornando uma data
	* DATE - NUMBER - Subtrai  um número de dias à data, retornando uma data
	* DATE - DATE - Retorna um número de dias 
	* DATE + NUMBER/24 - Adiciona um número de horas à data, retornando uma data
 


=================================================================================================================================================

AULA 45 - FUNÇÕES DE SISTEMA

=================================================================================================================================================	


	* USER - Mostra o nome do utilizador Oracle que abriu sessão
	* UID - Mostra o número que a base de dados atribuiu ao uilizador.
	* USERENV(arg) - Envolve dados da sessão atual, os valores de argumento podem ser vários


=================================================================================================================================================

AULA 46 - VIEWS

=================================================================================================================================================	

	A view pode ser definida como uma tabela virtual composta por linahs e colunas de dados vindos de tabelas relacionadas em uma query
	As linhas e colunas da view são geradas dinamicamente no momento em que é feita uma referência a ela.
	As views podem vir de  uma ou mais tabelas, ou até memso de outras views.

	VANTAGENS:

	* Reutilização
	* Segurança
	* Simplificação do Código


=================================================================================================================================================

AULA 47 - TEMP TABLES

=================================================================================================================================================

	TEMP TABLE (TEMPORARY) - indica que a tabela criada será temporária, 
	o que significa que ela expira assim que a sua sessão ou transação no Oracle terminar.
	Possui vida útil de uma sessão ou transação.


=================================================================================================================================================

AULA 49 - PL/SQL

=================================================================================================================================================

	PL/SQL é uma linguagem de progamação procedural da Oracle que estende a liguagem SQL.
	
	Utilizado em:
	* Bloco Anônimo 
	* Procedures
	* Triggers
	* Package 
	* Function 
	* Types
	

	***ESTRUTURA DE BLOCO PL/SQL***
	
	DECLARE - OPCIONAL
	-- Variáveis, cursores, exceções definidas pelo usuário

	BEGIN - Obrigatório
	-- Instruções SQL
	-- Instruções PL/SQL
	EXCEPTION - Opcional
	--Ações a serem desempenhadas quando ocorrem erros
	END; - Obrigatório

	
	Toda unidade PL/SQL compreende um ou mais blocos. 
	Onde esses blocos podem ser inteiramente separados ou aninhados um dentro do outro. 
	Existem 3 tipos de blocos:
		
		* Anônimo
			BEGIN
			- statements
			[EXCEPTION]
			END;
		* Procedimento
			PROCEDURE name
			IS
			BEGIN
			- statements
			[EXCEPTION]
			END;
		* Função
			FUNCTION name
			RETURN datatype	
			IS
			BEGIN
			- statements
			RETURN value;
			[EXCEPTION]
			END;

	
=================================================================================================================================================

AULA 50 - CONJUNTO DE CARACTERES

=================================================================================================================================================	

	Letras, Dígitos Símbolos
	
	PL/SQL é case-insensetive (compilador enxerga tudo como uppercase) e aceita caracteres A-Z, a-z, 0-9, whitespace e símbolos

	; = termina os statements e declarações
	% = inicador de atributo
	@ = indicador de localização
	<< e >> = delimitadores de labels
	:= = é indicador de atribuião de valores à variáveis, etc
	=> = é operador de associação para notação posicional
	.. (dois pontos) = é operador de range
	& = abre um prompt para digitar 

  
=================================================================================================================================================

AULA 51 - VARIAVEIS

=================================================================================================================================================


	Para inicializar uma variável pode utiliza o operador := ou a palavra chave DEFAULT

	

=================================================================================================================================================

AULA 52 - ATRIBUTOS TYPEE E ROTYPE

=================================================================================================================================================

	
	Para evitar erros de tipos, podemos utilizar o atributo %TYPE para declarar 
	a variável de acordo com a declaração de outra variável ou coluna da tabela  
	O atributo %TYPE é mais utilizado quando o valor armazenado na variável for 
	um valor derivado de uma oluna de uma tabelado banco.

Exemplo: 
	
	DECLARE
   		v_id hr.employees.employee_id%TYPE; -- CAMPO DA TABELA
   		v_emp hr.employees%ROWTYPE;         -- LINHA TODA DA TABELA 



=================================================================================================================================================

AULA 53 - TIPOS DE REGISTRO

=================================================================================================================================================

	Um registro é uma coleção de valores individuais que estão relacionados de alguma forma. 
	Com frequência os registros são usados para representar uma linha de uma tabela, e assim 	
	o relacionamento se baseia no fato de que todos os valores vêm da mesma linha. Cada campo
	de um registro é exclusivo e tem seus próprios valores. Um registro como um todo não tem valor
	Muito semelhante a declaração de um objeto em linguagens orientadas a objetos.

=================================================================================================================================================

AULA 54 - ESCOPOS DE VARIÁVEIS

=================================================================================================================================================


	Escopo de uma variável é a região de um programa no qual podemos referenciar a variável. 		
	Variáveis declaradas em blocos PLSQL são consideradas local para o bloco onde está declarado e 
	global para todos seus sub-blocos. Se uma variável é redeclarada em um sub-bloco, ambos 
	permanecem no escopo. 

	Não podemos declarar uma variável duas vezes no mesmo bloco, mas podemos declarar a mesma 
	variável em dois blocos diferentes. As duas variáveis são distintas, ou seja, qualquer
	mudança em uma, não irá afetar a outra.
	
	
=================================================================================================================================================

AULA 55 - IDENTIFICADORES

=================================================================================================================================================

	Um identificador é simplesmente um nome para um objeto PLSQL, ou uma palavra reservada. 
	As regras para os identificadores são as seguintes: 
	
	* Máximo de 30 caracteres
	* Devem começar com uma letra	
	* Podem incluir $, _ e # 
	* Não podem conter whitespace

=================================================================================================================================================

AULA 59 - GOTO

=================================================================================================================================================

	Com a declaração GOTO, o controle é transferido para a label incondicionalmente, onde temos também que o label
	deve ser único dentro de um escopo e deve ser posto antes de uma declaração executável ou mesmo de um bloco PLSQL

	Sintaxe:
		GOTO Label;

	O label tem por finalidade identificar tanto um bloco quanto uma declaração. 
	Caso o nosso label não esteja dentro do bloco no qual estejamos trabalhando, 
	a declaração GOTO irá transferir o controle para o primeiro bloco que contiver 
	na declaração da label.
	
	
=================================================================================================================================================

AULA 60 - LOOP FOR 

=================================================================================================================================================	


	[label] FOR index IN [ REVERSE ] menor_indice .. indice_maximo LOOP
		Declarações
	END LOOP [label];

	Index: nome dado a variável declarada implicitamente que é utilizada localmente na declaração do laço FOR 
	
	menor_indice (limite inferior) e maior_indice (limit superior): valores inteiros que são avaliados dentro de um laço
	Os valores que são postos estarão dentro desse limite  são temporários 
		
	Label: identifica uma declaração dentro do laço FOR, como instruções CONTINUE e EXIT, que podem referenciar a label.
	A utilização destes normalmente melhoram a legibilidade do código.


=================================================================================================================================================

AULA 61 - LOOP WHILE

=================================================================================================================================================	
 
	WHILE condition 
	  LOOP
	    {...statements...}	
	  END LOOP;


	A palavra "condition", que no caso é a condição que será testada a cada iteraão do loop. 
	Caso essa condição seja avaliada como TRUE, o corpo do loop será executado; caso esta 
	condição seja FALSE, o loop será então encerrado.
	
	O "statement" são as declarações do código que estaremos executando a cada passagem do loop. 	
	Como podemos perceber, a condição é realizada antes de entrarmos no loop, o que, em caso de ser	
	FALSE, o código pode não ser executado nenhuma vez.












