=================================================================================================================================================

AULA 05 

=================================================================================================================================================

ORACLE DATABASE -> DATAFILE -> TABLESPACE

-- criando tablespace

CREATE TABLESPACE curso 
	DATAFILE 	
	'C:\oraclexe\app\oracle\oradata\XE\curso.dbf' -- indicação do caminho onde o tablespace será criado
		size 100m autoextend on next 50m maxsize 500m
	online
	permanente
	extend management local autollocate
	segment space management auto;

-- criando user

CREATE USER aluno -- criação do usuário
	IDENTIFIED BY aluno -- senha 
	DEFAULT TABLESPACE curso -- direcionamento do tablespace
	TEMPORARY TABLESPACE TEMP; -- 
 
-- permissão para aluno

GRANT CREATE SESSION, CONNECT, RESOURCE TO aluno; -- permissões de conexões

ALTER USER ALUNO QUOTA UNLIMITED ON curso; -- alter para não ter limite no tablespace curso

-- deletar user
DROP USER aluno;

-- deletar tablespace 
DROP TABLESPACE curso
	INCLUDING CONTENTS AND DATAFILES 
		CASCADE CONTRAINTS;	

=================================================================================================================================================

AULA 11 - CARACTERISTICAS DE BANCO DE DADOS RELACIONAL

=================================================================================================================================================


Características do DB Relacional 

- É a arquitetura na qual os dados são armazenados em tabelas que se relacionam entre si.

	* Permite controle de redundância de dados;
	* Garantia de integridade dos dados;
	* Garantia de privacidade;
	* Otimização de espaço de Armazenamento;
	* Controle automático de relacionamento entre tabelas de dados;
	* Performance de acesso a informação;
	* Cada tabela (relação) tem seu nome diferente das demais na mesma base de dados;
	* Cada coluna tem seu nome diferente das demais na mesma tabela;
	* Colunas contém os atributos (todos do mesmo domínio);
	* Linhas contém informações de um registro (uma tupla) da tabela;
	* Cada célula pode conter no máximo um item de dado;
	* Ordem das linhas é irrelevante;
	* Ordem das colunas é irrelevante;
	* Nunca temos duas linhas iguais;
	* Chave primária;


=================================================================================================================================================

AULA 16 - ACID E CRUD

=================================================================================================================================================


ACID: (Propriedades das transações)
	
	* Atomicidade: uma transação é uma unidade atômica de processamento; ou ela é executada na sua totalidade, ou então nada é executado.
	* Consistência: a execução de uma transação deve manter a consistência de um banco de dados.
	* Isolamento: uma transação não deve tornar visível para outras transações as modificações feitas em um banco de dados até que ela seja encerrada com sucesso.
	* Durabilidade: uma vez executada com sucesso, as alterações feitas por uma transação deve, persistir, mesmo se houver subsequentes no sistema.


CRUD 
	* CREATE (CRIAR);
	* READ (SELECT);
	* UPDATE (ATUALIZAR);
	* DELETE (APAGAR);

=================================================================================================================================================

AULA 17 - CONSTRAINTS

=================================================================================================================================================

São utilizadas para especificar regras de armazenamento de dados nas tabelas e garantir integridade.

	* NOT NULL: Garante que uma coluna não recebera valor NULL;
	* UNIQUE: Garante que os valores em uma coluna sejam diferentes.
	* PRIMARY KEY: Chave única, linha exclusiva 
	* FOREIGN KEY: Referencia o valor de um campo em determinada linha a outra tabela 
	* DEFAULT: Define um valor padrão para uma coluna quando nenhum valor é especificado 
	* INDEX: Usado para criar e recuperar dados do banco de dados, melhor performance


=================================================================================================================================================

AULA 18 - OPERADORES DE COMPARAÇÃO 

=================================================================================================================================================

*** Permissões para select

GRANT SELECT ON HR.COUNTRIES TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.DEPARTMENTS TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.EMPLOYEES TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.JOB_HISTORY TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.JOBS TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.LOCATIONS TO ALUNO WITH GRANT OPTION;
GRANT SELECT ON HR.REGIONS TO ALUNO WITH GRANT OPTION;

-- EXEMPLO OPERADOR IGUAL =
SELECT * FROM HR.EMPLOYEES A
WHERE A.JOB_ID = 'IT_PROG';

-- EXEMPLO OPERADOR IGUAL =
SELECT * FROM HR.EMPLOYEES A
WHERE A.SALARY = '9000';

-- EXEMPLO OPERADOR MAIOR >
SELECT * FROM HR.EMPLOYEES A
WHERE A.HIRE_DATE > '03/02/2006'
ORDER BY A.HIRE_DATE ASC;

-- EXEMPLO OPERADOR MAIOR >

SELECT * FROM HR.EMPLOYEES A 
WHERE A.SALARY > '9000'
ORDE BY A.SALARY ASC;

-- EXEMPLO OPERADOR MENOR < 

SELECT * FROM HR.EMPLOYEES A
WHERE A.HIRE_DATE < '03/02/2006'
ORDER BY A.HIRE_DATE ASC;


-- EXEMPLO OPERADOR MAIOR IGUAL >=



=================================================================================================================================================

AULA 19 - OPERADORES MATEMÁTICOS 

=================================================================================================================================================

	+ ADIÇÃO
	- SUBTRAÇÃO
	* MULTIPLICAÇÃO
	/ DIVISÃO
	% MÓDULO -> RETORNA O RESTO INTEIRO DE UMA DIVISÃO

=================================================================================================================================================

AULA 20 - OPERADORES LÓGICOS/FILTROS

=================================================================================================================================================

WHERE - usada para extrair somente os registros/linhas que estiverem dentro das especificações da condição 
AND - TRUE se as duas expressões booleanas forem TRUE
BETWEEN - TRUE se o operando estiver dentro de um intervalo 
IN - TRUE se o operando for igual a um de uma lista de expressões 
LIKE - TRUE se o operando corresponder a um padrão
NOT - inverte o valor de qualquer outro operador booleano
OR - TRUE se qualquer expressão booleana for TRUE 
IS NULL - TRUE se o o valor for NULO
IS NOT NULL - TRUE se o valor não for NULO
HAVING - A cláusula HAVING foi adicionada ao SQL porque a palavra-chave WHERE não pôde ser usada com funções agregadas


CREATE TABLE senso 
(
ano INT NOT NULL,
cod_uf CHAR(2) NOT NULL,
estado VARCHAR(50) NOT NULL,
cod_mun CHAR(7) NOT NULL,
nome_mun varchar(50) NOT NULL,
regiao VARCHAR(150) NOT NULL,
pib DECIMAL(12,3) NOT NULL,
populacao INTEGER NOT NULL
);

=================================================================================================================================================

AULA 22 - STATMENT LANGUAGE

=================================================================================================================================================

DML - Data Manipulation Language
	SELECT - retornar dados do banco de dados
	INSERT - inserir dados em uma tabela
	UPDATE - atualiza dados existentes em uma tabela
	DELETE - exclui registros de uma tabela
DDL - Data Definition Language
	CREATE - para criar objetos no BD, o próprio BD, tabelas, indexes, procedures, views, functions, triggers
	ALTER - altera a estrutura do BD, o próprio BD, tabelas, indexes
	DROP - apaga objeto do BD, próprio BD, tabelas, indexes, procedures, views, triggers, e functions
	TRUNCATE - remove todos os registros de uma tabela, incluindo todos os espaços alocados para registros 
DCL - Data Control Language
	GRANT - atribui privilégios de acesso do usuário a objetos do BD
	REVOKE - remove privilégios de acesso do usuário a objetos do BD obtidos através do comando GRANT
TCL - Transaction Control Language                
	START TRANSACTION - 
	COMMIT - salvar o trabahlo feito
	SAVEPOINT - identificar um ponto em uma transação para que mais tarde possa efetua um ROLLBACK
	ROLLBACK - restaura BD ao original desde último COMMIT

=================================================================================================================================================

AULA 24 - DDL

=================================================================================================================================================

CREATE TABLE 
CREATE SEQUENCE 
CREATE INDEX

ALTER TABLE FUNCIONARIO ADD GENERO CHAR(1); -- adicionar campo

ALTER TABLE FUNCIONARIO RENAME COLUMN GENERO TO SEXO; --renomear coluna

ALTER TABLE FUNCIONARIO MODIFY SEXO VARCHAR2(1); --modificar tipo da coluna 

ALTER TABLE FUNCIONARIO RENAME TO PESSOA; -- renomear a tabela

ALTER TABLE PESSOA RENAME TO FUNCIONARIO; 

ALTER TABLE SENSO ADD ID INT; 

ALTER TABLE SENSO DROP COLUMN ID; --remover a coluna

ALTER TABLE FUNCIONARIO MODIFY ENDERECO VARCHAR2(30);

CREATE DATABASE TESTE; -- criar um banco de dados

DROP DATABASE TESTE; -- remover um banco de dados

DROP TABLE SALARIO;

CREATE VIEW V_FUNCIONARIO
 AS SELECT * FROM FUNCIONARIOS;

CREATE OR REPLACE VIEW V_FUNCIONARIO
AS SELECT ID, NOME FROM FUNCIONARIOS;

DROP  VIEW V_FUNCIONARIO;

CREATE OR REPLACE PROCEDURE PROC_QUADRADO (V_MUM1 NUMBER)
IS 
V_MUM2 NUMBER
BEGIN 
	V_MUM2 := V_MUM1 * V_MUM1;
	DBMS_OUTPUT.PUT_LINE('Retorno: ' || v_mum2);
END;

--CALL PROCEDURE 

BEGIN 
	POC_QUADRADO(V_MUM1 => 2)
END;

OU

SET SERVEROUTPUT ON;
EXECUTE PROC_QUADRADO(7);

DROP PROCEDURE PROC_QUADRADO;

CREATE GLOBAL TEMPORARY TABLE TMP_FUNCIONARIOS -- uma tabela tempoária só armazena os dados no tempo de uma próxima transação
(
	ID INT,
	NOME VARCHAR2(50),
	SALARIO DECIMAL(10, 2),
	SETOR VARCHAR2(30)
);

=================================================================================================================================================

AULA 26 - DCL GRANT

=================================================================================================================================================


GRANT UPDATE ON ALUNO.FUNCIONARIOS TO ALUNO;

GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW TO ALUNO WITH ADMIN OPTION;

GRANT SELECT, UPDATE ON ALUNO.SENSO TO ALUNO;

GRANT INSERT, DELETE ON ALUNO.SENSO TO ALUNO;

GRANT CREATE PROCEDURE, CREATE VIEW TO ALUNO;

SELECT 'GRANT ALL ON ' || object_name || ' TO ALUNO;' AS RETONO
	FROM USER_OBJECTS;


=================================================================================================================================================

AULA 26 - DCL REVOKE

=================================================================================================================================================

REVOKE CREATE VIEW, CREATE PROCEDURE, CREATE SESSION, CREATE TABLE FROM ALUNO;

REVOKE RESOURCE FROM ALUNO;

REVOKE UPDATE ON HELP FROM ALUNO;

=================================================================================================================================================

AULA 28 - TCL

=================================================================================================================================================


CREATE TABLE CADASTRO 
(
	NOME VARCHAR2(50) NOT NULL,
	NRO_DCTOVARCHAR2(20) NOT NULL
);

INSERT INTO CADASTRO VALUES ('Andre', '1234567');
INSERT INTO CADASTRO VALUES ('Joao', '9876541');
INSERT INTO CADASTRO VALUES ('Bruno', '1111111111');

ROLBACK;

COMMIT;

INSERT INTO CADASTRO VALUES ('Andre', '1234567');
SAVEPOINT P1;
INSERT INTO CADASTRO VALUES ('Joao', '9876541');
SAVEPOINT P2;
INSERT INTO CADASTRO VALUES ('Bruno', '1111111111');
SAVEPOINT P3;

ROLLBACK TO SAVEPOINT P2;

COMMIT;

=================================================================================================================================================

AULA 29 - OPERADOR UNION / UNION ALL

=================================================================================================================================================

Operador UNION é usado para combinar o conjunto de resultados de duas ou mais instruções SELECT 
É necessário que cada select dentro do union possua o mesmo número de colunas e do mesmo tipo
As colunas também devem ser tipos de dados semelhantes 
As colunas em cada instrução select deve estar na mesma ordem 
O operador UNION seleciona apenas valores distintos por padrão (realiza um DISTINCT)
Para permitir valores duplicados é necessário o UNION ALL



=================================================================================================================================================

AULA 30 - JOINS

=================================================================================================================================================


Esta clausula é suada para combinar as linhas de duas ou mais tabelas baseado no relacionamento entre elas.

Aqui estão os diferentes tipos de JOINS em SQL:

  * INNER JOIN: Retorna os registros que têm valores correspondentes em ambas as tabelas
  * LEFT JOIN: Retorna todos os registros da tabela à esquerda e os registros correspondentes da tabela da direita  
  * RIGHT JOIN: Retorna todos os registros da tabela à diretia e os registros correspondentes da tabela da esquerda  
  * FULL OUTER JOIN: retorna todos os registros quando houver uma correspondência na tabela à esquerda ou à direita

*************************************************************************************************************************************************  
*** Consulta para verificar todas as tabelas				***  Consulta para verificar tipos 	  			      ***
***									***								      ***
*** SELECT OWNER, TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH	***  SELECT OWNER, TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH    ***
*** FROM all_tab_columns						***  FROM all_tab_columns					      ***
***									***  WHERE DATA_TYPE = 'VARCHAR'				      ***
***									***								      ***
*************************************************************************************************************************************************


=================================================================================================================================================

AULA 31 - SUBQUERYS

=================================================================================================================================================

É uma instrução SELECT que está condicionada dentro de outra instrução SQL.

Existem, no entanto, 4 maneiras de introduzirmos uma subconsulta em uma instrução do tipo SELECT:
	
	* Através do WHERE como sendo uma condição de pesquisa
	* Em uma cláusula HAVING como condição de pesquisa
	* na cláusula FROM como uma especificação de tabela
	* na cláusula SELECT como uma especificação de coluna   


=================================================================================================================================================

*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*  FUNÇÕES PADRÕES  */*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*

=================================================================================================================================================

AULA 33 e 34 - FUNÇÕES DE AGREGAÇÃO

=================================================================================================================================================

Executam um cálculo em um conjunto de valores e retornam um único valor.
Com exceção de COUNT, as funções de agregação ignorma valores nulos.
A funções de agregação normalmente são usadas com a cláusula GROUP BY da instrução SELECT
As funções de agregação podem ser usadas como expressões apenas nos seguintes casos:
  * A lista de seleção de uma instrução select (uma subconsutla ou uma consulta externa)
  * Uma cláusula HAVING.


AVG - Retorna a média dos valores em um grupo. Valores nulos são ignorados
MIN - Retorna o valor mínimo da expressão. Pode ser seguido pela cláusula OVER
MAX - Retorna o valor máximo na expressão
SUM - Retorna a soma de todos os valores ou somente os valores DISTINCT na expressão. 
      SUM pode ser usado exclusivamente com colunas numéricas. Valores nulos são ignorados 
COUNT - Retorna o número de itens de um grupo
STDDEV - Retorna o desvio padrão estatístico de todos os valores da expressão especificada 
VARIANCE - Determina a variância de N,ignorando valores nulos  

-- consulta que traz o estado, 
-- sua média populacional agrupado por estado, 
-- população mínima, população máxima, 
-- soma da população agrupado por estado 
-- e a quantidade de cidades tendo em vista a contagem de linhas agrupado por estado e ano 
-- (ano nesse caso auxilia a ter uma exatidão pois se não separasse por ano traria o registro de todos anos)  

SELECT 
	a.estado,
       	AVG(a.populacao) as media_pop,
	MIN(a.populacao) as minimo_pop,
	MAX(a.populacao) as maximo_pop,
	SUM(a.populacao) as total_pop,
	COUNT(*) as qtd_cidades
FROM senso a 
WHERE a.ano = '2014'
GROUP BY a.estado
ORDER BY 2 DESC;

-- consulta mais aprimorada em relação a outra que só demonstrava números
-- nela é possível verificar o nome do estado e do município com a população máxima

SELECT a.estado, a.nome_mun, a.populacao
FROM
	(SELECT b.estado, MAX(b.populacao) as populacao from senso b
	 WHERE b.ano = '2014'
	 GROUP BY b.estado
	) b
JOIN senso a
ON a.estado = b.estado
AND a.populacao = b.populacao
WHERE a.ano = '2014'
ORDER BY a.populacao DESC; 


-- COMPARANDO CRESCIMENTO pop DA CIDADES ref anos  2010 a 2014
-- select cod_uf,cod_mun,cod_uf+cod_mun as concatenado from cidades
-- usando exemplo
SELECT a.nome_mun,
       a.populacao as senso_2010,
	   b.populacao as senso_2014,
       (100/a.populacao)*(b.populacao)-100 as percentual
from senso a 
inner join senso b 
on a.cod_mun=b.cod_mun
where a.ano='2010' 
and b.ano='2014';

-- VAR_POP Retorna a variância estatística de todos os valores da expressão especificada
SELECT VAR_POP(POPULACAO) FROM senso
where ano='2014';

-- VAR_SAMP Retorna a variância estatística para o preenchimento 
-- de todos os valores da expressão especificada.
SELECT VAR_SAMP(POPULACAO) FROM senso;


=================================================================================================================================================

AULA 39 - FUNÇÕES MATEMÁTICAS

=================================================================================================================================================

	* ABS - Uma função matemática que retorna o valor absoluto (positivo) da expressão numérica especificada
	* DBMS_RANDOM - Retorna um valor float pseudoaleatório de 0 a 1, exclusivo
	* ROUND - Retorna um valor numérico, arredondado, para o comprimento ou precisão especificados
	* TRUNC - Trunca as casas decimais de uma expressão
	* SQRT - Retorna a raiz quadrada de uma expressão
	* SIGN - Retorno -1 para negativo, 0 neutro, 1 para positivo com o valor da expressão
	* POWER - Eleva à potência de N o valor. Pode ser nagativo
	* MOD - Retorna o valor MOD, a sobra de uma expressão dividida
	* EXP - Devolve o valor 'e' elevado a N

=================================================================================================================================================

AULA 40 - FUNÇÕES DE CRIPTOGRAFIA

=================================================================================================================================================

	* RAWTOHEX - Converte os caracteres para hexadecimal
	* DBMS_OBFUSCATION_TOOLKIT - Esse pacote disponibiliza o método MD5 e outros 
	* UTL_RAW - Nesse ponto há manipulação dos dados, tendo como foco principal: a conversão dos tipos
	

SET SERVEROUTPUT ON


DECLARE
     v_str VARCHAR2(100);
     v_frase VARCHAR2(100);
    BEGIN
     -- atribuindo valor
     v_frase:='Utilidades Oracle';
      --generate encoded value
      --1 PARAM BUF VALOR
      --2 PARAM ENCODE_CHARSET SAO TIPO WE8ISO8859P1 - AL32UTF8
      --3 PARAM ENCODING - BASE64
      v_str := utl_encode.text_encode(v_frase,'WE8ISO8859P1', UTL_ENCODE.BASE64);
      --imprimi valor
      dbms_output.put_line(v_str);
      
      --take the encoded value and decode it
      v_str := utl_encode.text_decode(v_str,'WE8ISO8859P1', UTL_ENCODE.BASE64);
      --imprimi valor
     dbms_output.put_line(v_str);
     
   END;


=================================================================================================================================================

AULA 41 - FUNÇÕES DE LIMITE

=================================================================================================================================================

	* ROWNUM - A cláusula SELECT ... LIMIT é útil em grandes tabelas com milhares de registros 
	


=================================================================================================================================================

AULA 42 - FUNÇÕES DE CONVERSÃO

=================================================================================================================================================

	* CAST - Converte expressão de um tipo de dados em outro
	* TO_CHAR(data) - Converte data em string
	* TO_DATE(string) - Converte string em data 
	* NVL() - Trata valor nulo 


=================================================================================================================================================

AULA 43 - FUNÇÕES DE DATAS

=================================================================================================================================================	


	* SYSDATE - Retorna a data e hora atual do servidor 
	* ADD_MONTHS - Adiciona N meses de calendário à data. O número N tem que ser inteiro e pode ser negativo
	* MONTHS_BETWEEN - Determina o número de meses entre data1 e data2. O resultado pode ser positivo ou negativo.
	* LAST_DAY - Devolve o último dia do mês de data1 
	* NEXT_DAY - Devolve a data do próximo dia da semana especificado por C e A seguido da data1

Utilização de operadores aritméticos

	* DATE + NUMBER - Adiciona um número de dias à data, retornando uma data
	* DATE - NUMBER - Subtrai  um número de dias à data, retornando uma data
	* DATE - DATE - Retorna um número de dias 
	* DATE + NUMBER/24 - Adiciona um número de horas à data, retornando uma data
 


=================================================================================================================================================

AULA 45 - FUNÇÕES DE SISTEMA

=================================================================================================================================================	


	* USER - Mostra o nome do utilizador Oracle que abriu sessão
	* UID - Mostra o número que a base de dados atribuiu ao uilizador.
	* USERENV(arg) - Envolve dados da sessão atual, os valores de argumento podem ser vários


=================================================================================================================================================

AULA 46 - VIEWS

=================================================================================================================================================	

	A view pode ser definida como uma tabela virtual composta por linahs e colunas de dados vindos de tabelas relacionadas em uma query
	As linhas e colunas da view são geradas dinamicamente no momento em que é feita uma referência a ela.
	As views podem vir de  uma ou mais tabelas, ou até memso de outras views.

	VANTAGENS:

	* Reutilização
	* Segurança
	* Simplificação do Código


=================================================================================================================================================

AULA 47 - TEMP TABLES

=================================================================================================================================================

	TEMP TABLE (TEMPORARY) - indica que a tabela criada será temporária, 
	o que significa que ela expira assim que a sua sessão ou transação no Oracle terminar.
	Possui vida útil de uma sessão ou transação.


=================================================================================================================================================

AULA 49 - PL/SQL

=================================================================================================================================================

	PL/SQL é uma linguagem de progamação procedural da Oracle que estende a liguagem SQL.
	
	Utilizado em:
	* Bloco Anônimo 
	* Procedures
	* Triggers
	* Package 
	* Function 
	* Types
	

	***ESTRUTURA DE BLOCO PL/SQL***
	
	DECLARE - OPCIONAL
	-- Variáveis, cursores, exceções definidas pelo usuário

	BEGIN - Obrigatório
	-- Instruções SQL
	-- Instruções PL/SQL
	EXCEPTION - Opcional
	--Ações a serem desempenhadas quando ocorrem erros
	END; - Obrigatório

	
	Toda unidade PL/SQL compreende um ou mais blocos. 
	Onde esses blocos podem ser inteiramente separados ou aninhados um dentro do outro. 
	Existem 3 tipos de blocos:
		
		* Anônimo
			BEGIN
			- statements
			[EXCEPTION]
			END;
		* Procedimento
			PROCEDURE name
			IS
			BEGIN
			- statements
			[EXCEPTION]
			END;
		* Função
			FUNCTION name
			RETURN datatype	
			IS
			BEGIN
			- statements
			RETURN value;
			[EXCEPTION]
			END;

	
=================================================================================================================================================

AULA 50 - CONJUNTO DE CARACTERES

=================================================================================================================================================	

	Letras, Dígitos Símbolos
	
	PL/SQL é case-insensetive (compilador enxerga tudo como uppercase) e aceita caracteres A-Z, a-z, 0-9, whitespace e símbolos

	; = termina os statements e declarações
	% = inicador de atributo
	@ = indicador de localização
	<< e >> = delimitadores de labels
	:= = é indicador de atribuião de valores à variáveis, etc
	=> = é operador de associação para notação posicional
	.. (dois pontos) = é operador de range
	& = abre um prompt para digitar 

  
=================================================================================================================================================

AULA 51 - VARIAVEIS

=================================================================================================================================================


	Para inicializar uma variável pode utiliza o operador := ou a palavra chave DEFAULT

	

=================================================================================================================================================

AULA 52 - ATRIBUTOS TYPEE E ROTYPE

=================================================================================================================================================

	
	Para evitar erros de tipos, podemos utilizar o atributo %TYPE para declarar 
	a variável de acordo com a declaração de outra variável ou coluna da tabela  
	O atributo %TYPE é mais utilizado quando o valor armazenado na variável for 
	um valor derivado de uma oluna de uma tabelado banco.

Exemplo: 
	
	DECLARE
   		v_id hr.employees.employee_id%TYPE; -- CAMPO DA TABELA
   		v_emp hr.employees%ROWTYPE;         -- LINHA TODA DA TABELA 



=================================================================================================================================================

AULA 53 - TIPOS DE REGISTRO

=================================================================================================================================================

	Um registro é uma coleção de valores individuais que estão relacionados de alguma forma. 
	Com frequência os registros são usados para representar uma linha de uma tabela, e assim 	
	o relacionamento se baseia no fato de que todos os valores vêm da mesma linha. Cada campo
	de um registro é exclusivo e tem seus próprios valores. Um registro como um todo não tem valor
	Muito semelhante a declaração de um objeto em linguagens orientadas a objetos.

=================================================================================================================================================

AULA 54 - ESCOPOS DE VARIÁVEIS

=================================================================================================================================================


	Escopo de uma variável é a região de um programa no qual podemos referenciar a variável. 		
	Variáveis declaradas em blocos PLSQL são consideradas local para o bloco onde está declarado e 
	global para todos seus sub-blocos. Se uma variável é redeclarada em um sub-bloco, ambos 
	permanecem no escopo. 

	Não podemos declarar uma variável duas vezes no mesmo bloco, mas podemos declarar a mesma 
	variável em dois blocos diferentes. As duas variáveis são distintas, ou seja, qualquer
	mudança em uma, não irá afetar a outra.
	
	
=================================================================================================================================================

AULA 55 - IDENTIFICADORES

=================================================================================================================================================

	Um identificador é simplesmente um nome para um objeto PLSQL, ou uma palavra reservada. 
	As regras para os identificadores são as seguintes: 
	
	* Máximo de 30 caracteres
	* Devem começar com uma letra	
	* Podem incluir $, _ e # 
	* Não podem conter whitespace

=================================================================================================================================================

AULA 59 - GOTO

=================================================================================================================================================

	Com a declaração GOTO, o controle é transferido para a label incondicionalmente, onde temos também que o label
	deve ser único dentro de um escopo e deve ser posto antes de uma declaração executável ou mesmo de um bloco PLSQL

	Sintaxe:
		GOTO Label;

	O label tem por finalidade identificar tanto um bloco quanto uma declaração. 
	Caso o nosso label não esteja dentro do bloco no qual estejamos trabalhando, 
	a declaração GOTO irá transferir o controle para o primeiro bloco que contiver 
	na declaração da label.
	
	
=================================================================================================================================================

AULA 60 - LOOP FOR 

=================================================================================================================================================	


	[label] FOR index IN [ REVERSE ] menor_indice .. indice_maximo LOOP
		Declarações
	END LOOP [label];

	Index: nome dado a variável declarada implicitamente que é utilizada localmente na declaração do laço FOR 
	
	menor_indice (limite inferior) e maior_indice (limit superior): valores inteiros que são avaliados dentro de um laço
	Os valores que são postos estarão dentro desse limite  são temporários 
		
	Label: identifica uma declaração dentro do laço FOR, como instruções CONTINUE e EXIT, que podem referenciar a label.
	A utilização destes normalmente melhoram a legibilidade do código.


=================================================================================================================================================

AULA 61 - LOOP WHILE

=================================================================================================================================================	
 
	WHILE condition 
	  LOOP
	    {...statements...}	
	  END LOOP;


	A palavra "condition", que no caso é a condição que será testada a cada iteração do loop. 
	Caso essa condição seja avaliada como TRUE, o corpo do loop será executado; caso esta 
	condição seja FALSE, o loop será então encerrado.
	
	O "statement" são as declarações do código que estaremos executando a cada passagem do loop. 	
	Como podemos perceber, a condição é realizada antes de entrarmos no loop, o que, em caso de ser	
	FALSE, o código pode não ser executado nenhuma vez.


=================================================================================================================================================

AULA 63 - EXCEÇÕES

=================================================================================================================================================	
 
	Geralmente, quando um erro ocorre, o processamento do bloco PLSQL é imediatamente encerrado.
	O processamento corrente não é concluído. O oracle permite que você esteja preparado para esses 
	erros e implemente lógica nos programas para lidar com os erros.
	
	Existem 3 tipos de exceções:
	* Erros Predefinidos da Oracle;
	* Erros não definidos da Orace;
	* Erros definidos pelo usuário.

	ERROS PREDEFINIDOS PELO ORACLE:
	
	* no_data_found - o SELECT de linha única não retornou dados;
	* too_many_rows - o SELECT de linha única retornou mais de uma linha;
	* invalid_cursor - Houve a tentativa de operação ilegal de cursor;
	* value_error - Ocorreu um erro de aritmética, conversão, truncagem ou restrição;
	* invalid_number - A conversão de uma string para um número, falhou;
	* zero_divide - Ocorreu uma tentativa de dividir por zero;
	* dup_val_on_index - Houve uma tentativa de inserir, em duplicata, um valor em 
	  uma coluna (ou conjunto de colunas) que possui um índice exclusivo;
	* cursor_already_open - Houve uma tentativa de abrir um curso que foi aberto anteriormente;
	* not_logged_on - Uma chamada de banco de dados foi feita sem o usuário estar conectado ao Oracle;
	* transaction_backed_out - Uma parte remota de uma transação teve "rollback";
	* login_denied - um login do banco de dados Oracle falhou po causa de um nome de usuário e/ou senha inválidos;
	* program_error - O PLSQL encontrou um problema interno;
	* storage_error - O PLSQL ficou sem memória ou a memória está corrompida;
	* timeout_on_resouce - Um timeout ocorreu enquanto o Oracle estava esperando por um Recurso;
	* rowtype_mismatch - Uma variável de cursor não é incompatível com a linha de cursor;
	* Others - Uma declaração catchall que detecta um erro que não foi detectado nas exceções anteriores

	ERROS INDEFINIDOS DA ORACLE:
	
	Conseguimos capturar erros não definidos pelo servidor Oracle declarando-os primeiro ou usando o manipulador OTHERS.
	A exceção declarada é invocada implicitamente. No PLSQL, o PRAGMA EXCEPTION_INIT() "diz" para o compilador para 
	associar uma exceção com um número de erro Oracle. Isto permite referenciar em qualquer exceção interna pelo nome
	e escrever um manipulador específico para isto.
	
	*IMPORTANTE*: PRAGMA é uma palavra reservada e uma diretiva de compilação que não é processada quando um bloco 
	é executado. Ele direciona o compilador do PLSQL para interpretar todas ocorrências de nomes de exceção dentro 
	de um bloco como número de erro do servidor Oracle.

	
	ERROS DEFINIDOS PELO USUÁRIO
	
	Um usuário pode levantar explicitamente uma exceção usando o comando RAISE. Esse procedimento deve ser usado apenas quando 
	o Oracle não levanta sua própria exceção ou quando o processamento não é desejado ou é impossível de ser completado.
	
	As etapas para levantar e tratar um erro definido pelo usuário, são os seguintes: 
	
	1. Declarar o nome para a exceção de usuário dentro da seção de declaração do bloco;
	
	2. Levantar a exceção explicitamente dentro da parte executável do bloco, usando o comando RAISE;
	
	3. Referenciar a exceção declarada com uma rotina de tratamento de erro.


	SQLCODE e SQLERRM:

	* SQLCODE: Retorna um valor numérico para o código de erro;
	* SQLERRM: Retorna um caractere contendo a mensagem associada com o número do erro.

	
=================================================================================================================================================

AULA 65 - CURSORES

=================================================================================================================================================	
 	
	Os cursores PLSQL fornecem um modo pelo qual seu programa pode selecionar várias linhas de dados de Banco 
	de Dados e depois processar cada linha individualmente. Especificamente, um cursor é um nome atribuído pela 
	Oracle para cada declaração SQL que é processada. Esse nome fornece à Oracle um meio de orientar e controlar 
	todas as fases do processamento do SQL.
	
	* Conceitos Básicos:
 	
	- Existem dois tipos de cursores:
		
		* Cursor Implícito - são cursores delcarados pelo PLSQL implicitamente para todos comandos DML e comandos
			             SELECT no PLSQL, independente da quantidade de registros processados. Ele precisa fazer
				     isso para gerenciar o processamento da declaração SQL.
	

		* Cursor Explícito - Cursores definidos pelo usuário para manipular registros recuperados por declarações SELECT.  
	
	CICLO DE VIDA DO CURSOR:

	1. Declare o cursor nomeando o mesmo e defina a estrutura da consulta que será realizada por ele;
	
	2. Através do comando OPEN, o cursor é aberto e executa a consulta que recuperará o conjunto ativo do banco de dados;
	
	3. Com o comando FETCH, capturamos os dados do registro corrente que utilizarmos em nosso programa. A cada comando FETCH, 
	   devemos testar se ainda existe registro no cursor e abandonar o LOOP do cursor através do comando EXIT, caso não exista
	   (mais adiante veremos como verificar isso);
	
	4. Quando a manipulação dos dados do cursor for finalizada, ao abandonar o LOOP do cursor, devemos fecha-los através o comando CLOSE,
	   que libera as linhas do cursor;

	
	ATRIBUTOS DE CURSORES EXPLÍCITOS 
	
	* %rowcount - Mostra o núemro de linhas do cursor;
	* %found - retorna TRUE se o mais recente FETCH retornar uma linha;
	* %notfound - retorna TRUE se o mais recente FETCH não retornar uma linha;
 	* %isopen - retorna TRUE se o cursor estiver aberto
	
	CURSORES EXPLÍCITOS AUTOMATIZADOS (LOOP Cursor FOR)
	
	Os LOOPs Cursor FOR são ideais quando você quer fazer o LOOP em todos os registros retornados pelo cursor.
	
	Com o LOOP Cursor FOR não se deve delcarar o registro que controla o LOOP. Da mesma forma, não se deve usá-lo 
	quando as operações do cursor precisarem ser tratadas manualmente.
	
	O LOOP Cursor FOR realiza as seguintes ações implicitamente:
		
	1. Declara o índice do LOOP;
	2. Abre o Cursor;
	3. Faz o FETCH da linha seguinte a partir do cursor para cada iteração do LOOP;
	4. Fecha o cursor quando todas as linahs são processadas ou quando o LOOP é encerrado.

	O LOOP Cursor FOR processa linhas em um cursor explícito. Isto é uma facilidade por que o cursor é aberto,
	linhas são carregadas em cada iteração do LOOP, o LOOP é finalizado quando a última linha é processada e o
	cursor é fechado, automaticamente.

	 
=================================================================================================================================================

AULA 72 - FUNÇÕES

=================================================================================================================================================	

	Uma function é um bloco PLSQL semelhante a procedure, com a diferença de que functios retornam valores, 
	(procedures podem ou não retornar valores) tendo como características: 

	* Functions sempre retornam valores;
	* Functions são usadas como parte de uma expressão;

	Estrutura da Function: 
	
	CREATE OR REPLACE FUNCTION function_name (parameter_name [IN | OUT | IN OUT] type)
		RETURN return_data_type
		[IS | AS]
		BEGIN
			< function_body >

		END function_name;

	
	ESTRUTURA FUNCTION EXPLICADA:
 	
	* CREATE OR REPLACE FUNCTION - Caso uma function já exista com o mesmo nome ela será reescrita devido ao termo replace; 
	* function_name - será o nome atribuído para essa função;
	* parameters - a lista opcional de parâmetros contém os nomes, os modos e os tipos que esses parâmetros terão. O IN 
		       representa o valor que será passado de fora, já OUT representa que este parâmetro será utilizado para 
		       retornar um valor de fora do procedimento;
	* RETURN data_type - é o tipo de retorno que será utilizado, sendo este SQL ou PLSQL . Podemos neste caso utilizar
			     referências como o %TYPE ou %ROWTYPE se necessário, ou mesmo utilizar qualquer tipo de dados escalar 
		             ou composto;
	* IS/AS - por convenção, temos o IS para a criação de funções armazenadas e o AS quando criamos pacotes (packages);
	* function_body - contém o bloco PLSQL que inicia com a cláusula BEGIN e finaliza com END [function_name], e executa neste 
			  momento todas as instruções necessárias.

	
=================================================================================================================================================

AULA 79 - PROCEDURES

=================================================================================================================================================	


	Stored Procedure é um bloco de instruções PLSQL que executa uma ou mais tarefas específicas. Possui normalmente um cabeçalho e um corpo.
	O cabeçalho consiste do nome e de parâmetros ou variáveis que serão passadas para a procedure. Já o corpo consiste da declaração de uma 
	seção, execução de uma seção e uma seção de exceções muito similar a um bloco geral PLSQL. Uma procedure pode ou não ter um valor de retorno.
	Normalmente as procedures são criadas dentro de pacotes ou em blocos PLSQL.
	Podemos passar os parâmetros para uma procedure de 3 maneiras: 
		
	* Parâmetros IN - passsamos o valor a própria procedure.
	* Parâmetros OUT - recebemos o valor a partir da chamada de blocos externos.
	* Parâmetros IN/OUT - passamos um valor inicial para a procedure e recebemos de volta uma atualização.	

	*** ESTRUTURA PROCEDURE ***
	
	CREATE OR REPLACE PROCEDURE proc_name(parameters)
	IS
		declaration SECTION
	BEGIN
		execution SECTION
	EXCEPTION
		exception SECTION
	END proc_name;	

	***OBS*** o 'IS' marca o início do corpo de uma procedure e ´bem similar ao DECLARE de um bloco anônimo PLSQL.
	   	  O código criado entre o IS e o BEGIN forma a seção de declaração da procedure.


=================================================================================================================================================

AULA 87 - TRIGGERS

=================================================================================================================================================

	Tipos de Triggers:
	
	As triggers podem ser do tipo ROW LEVEL ou STATEMENT. Elas podem ocorrer (BEFORE) antes, ou (AFTER) depois que a ação 
	tenha ocorrido,e por fim pode ocorrer para as ações de INSERT, UPDATE e DELETE em uma tabela.
	
	* ROW LEVEL (Linha)

		Essas triggers são utilizadas para operações como:
			- Gravação de LOGS de auditoria de uma aplicação;
			- Verificação de dados (Consistência);
			- Implementação de integridade referencial.

	* STATEMENT (Tabela)

		Essas tem a finalidade de tratar a execução de ações sobre tabelas independentemente de quantas linhas forem
		afetadas. Através deste tipo de Trigger podemos registrar a execução de comandos INSERT, UPDATE e DELETE contra
		tabelas que tenham Triggers contemplando essas ações.

	ELEMENTOS: 
	
	* Tempo: (BEFORE/AFTER) - Quando a trigger dispara em relação ao evento de acionamento (DML);
	
	* Evento de acionamento (INSERT/UPDATE/DELETE) - Quais operações de manipulação de tabela (DML) disparam a trigger;
			
	* Abrangência da trigger (for each row / de instrução) - Quantas vezes o corpo da trigger será executada;
	
	* Corpo da triggr (Bloco) - Que ações serão executadas


	MODIFICADORES OLD E NEW:

	Podemos nos casos de triggers de linha, fazer referência a valores contidos nas colunas e com isso podemos querer saber
	os valores antes da alteração e depois dos valores efetivamente alterados. Isso vale na ação de UPDATE, nos casos de INSERT
	e DELETE os valores de OLD (INSERT) e NEW (DELETE) são nulos. Estes modificadores podem ser usados apenas em triggers. Não 
	podemos usá-los em pocedures, functions ou packages.

	Os valores são referenciados da seguinte forma	
	
		:OLD.nomecoluna e :NEW.nomecoluna

	Não importa se a tigger for BEFORE ou AFTER os modificadores OLD e NEW não são afetados.


	OPERADORES: INSERTING UPDATING E DELETING

	Podemos criar Triggers para serem disparados para várrias ações de banco de dados. Dessa forma como podemos diferenciar uma 
	ação de insert de outra de delete ou ainda update. Estes modificadores podem ser feitos apenas dentro de triggers.

	
	RESTRIÇÕES: 
	
	Não podemos realizar comandos COMMIT, ROLLBACK, SAVEPOINT em uma trigger, mesmo que seja uma procedure executada em um triger

	Não podemos fazer selct na mesma tabela que sofre a ação de uma trigger, pois isso pode povocar um erro chamado MUTANT TABLE.
	Mesmo porque se quisemos saber o valor de uma coluna do registro que está sendo tratado em um trige basta colarmos :NEW.nomecoluna
	ou :OLD.nomecoluna para termos respectivamente os valores atuais e anteriores a alteração.
	
	Triggers tornam as operações mais lentas, isso ocorre principalmente em casos de Triggers de linha.  

	
=================================================================================================================================================

AULA 89 - PACKAGES

=================================================================================================================================================

	Um package é uma coleção de objetos PLSQL agrupados logicamente sob o nome de pacote. Os packages podem incluir procedures, 
	functions, cursores, declarações tipos e também variáveis.
		
	Os packages geralmente possuem duas partes uma que se refere a spec e a segunda parte que é o body.	


	SPEC: 

 	É o que chamamos de intrface para o package. É nela que declaramos os tipos, variáveis, constantes, exceções, cursores e 
	subprogramas que poderão ser referenciados a partir de partes externas ao package.
	

	BODY: 

	Onde é definido as consultas para os cursores e o código para os subprogramas. Em alguns casos pode ser que haja a necessidade 
	de se ter um body.
	

	Package PLSQL é um subgrupo de funções relacionadas, procedimentos, tipos, cursores dentre outros. Os packages são como uma biblioteca
	pois uma vez escrito é armazenado no banco de dados Oracle e pode ser usado por muitas aplicações.

